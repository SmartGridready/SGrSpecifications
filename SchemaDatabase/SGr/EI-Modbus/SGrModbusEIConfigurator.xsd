<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Copyright (c) 2023, SmartGridready, Switzerland. All rights reserved. Source https://github.com/SmartgridReady/SGrSpecifications  -->
<schema xmlns="http://www.w3.org/2001/XMLSchema" xmlns:sgr="http://www.smartgridready.com/ns/V0/" attributeFormDefault="unqualified" elementFormDefault="qualified"
  targetNamespace="http://www.smartgridready.com/ns/V0/" version="0.2.2">
  <include schemaLocation="../Generic/SGrGenTypeDefinitions.xsd"/>
  <include schemaLocation="SGrModbusEIDataTypes.xsd"/>
  <complexType name="ModbusAttributes">
    <annotation>
      <documentation>Modbus Attributes support TransportService specific parameters
      </documentation>
    </annotation>
    <all>
      <element maxOccurs="1" minOccurs="0" name="scalingFactor" type="sgr:ScalingFactor">
        <annotation>
          <documentation>
            generic value = dataPoint * m * 10^p
          </documentation>
        </annotation>
      </element>
      <element maxOccurs="1" minOccurs="0" name="stepByIncrement" type="unsignedInt">
        <annotation>
          <documentation>each didgit</documentation>
        </annotation>
      </element>
      <element maxOccurs="1" minOccurs="0" name="sunssf" type="unsignedInt">
        <annotation>
          <documentation>
            a Sunpec specific attribute (scalefactor p -10 ... +10) generic value = dataPoint * 10^p note: Sunspec uses sunssf usually as Modbus Register with dynamic values check
            attribute "timeAlignedNotification"
          </documentation>
        </annotation>
      </element>
      <element maxOccurs="1" minOccurs="0" name="pollingLatencyMs" type="unsignedInt">
        <annotation>
          <documentation>
            the time for a master slave communication cycle in ms
          </documentation>
        </annotation>
      </element>
      <element name="accessProtection" type="sgr:AccessProtectionEnabled" maxOccurs="1" minOccurs="0"/>
      <element name="layer6Deviation" type="sgr:ModbusLayer6Deviation" maxOccurs="1" minOccurs="0"/>
      <element name="iopEnumMapper" type="sgr:ModbusEnumMapper" maxOccurs="1" minOccurs="0"/>
      <element name="iopBitmapMapper" type="sgr:ModbusBitmapMapper" maxOccurs="1" minOccurs="0"/>
      <element name="iopBooleanMapper" type="sgr:ModbusBooleanMapper" maxOccurs="1" minOccurs="0"/>
    </all>
  </complexType>
  <complexType name="ModbusInterfaceDescription">
    <sequence>
      <element maxOccurs="1" minOccurs="1" name="modbusInterfaceSelection" type="sgr:ModbusInterfaceSelection"/>
      <element maxOccurs="1" minOccurs="0" name="modbusTcp" type="sgr:ModbusIp"/>
      <element maxOccurs="1" minOccurs="0" name="modbusRtu" type="sgr:ModbusRtu"/>
      <element maxOccurs="1" minOccurs="1" name="firstRegisterAddressIsOne" type="boolean"/>
      <element maxOccurs="unbounded" minOccurs="1" name="bitOrder" type="sgr:BitOrder"/>
    </sequence>
  </complexType>
  <simpleType name="ModbusInterfaceSelection">
    <restriction base="string">
      <enumeration value="RTU"/>
      <enumeration value="TCPIP"/>
      <enumeration value="UDPIP"/>
      <enumeration value="RTU-ASCII"/>
      <enumeration value="TCPIP-ASCII"/>
      <enumeration value="UDPIP-ASCII"/>
    </restriction>
  </simpleType>
  <complexType name="ModbusDataPointConfiguration">
    <sequence>
      <element maxOccurs="1" minOccurs="1" name="modbusDataType" type="sgr:ModbusDataType"/>
      <element maxOccurs="1" minOccurs="1" name="modbusFirstRegisterReference" type="sgr:ModbusFirstRegisterReference"/>
      <element maxOccurs="1" minOccurs="1" name="numberOfRegisters" type="int"/>
      <element maxOccurs="unbounded" minOccurs="1" name="masterFunctionsSupported" type="sgr:MasterFunctionsSupported">
        <annotation>
          <documentation>
            Available function/command codes for Master / Clients The various reading, writing and other operations are categorized as follows. The most "primitive" reads and writes are
            A number of sources use alternative terminology, for example Force Single Coil where the standard uses Write Single Coil.[11] Prominent entities within a Modbus slave are:
            ReadDiscreteInputs (code: 2) ReadCoils (code: 1) WriteSingleCoil (code: 5) WriteMultipleCoils (code:15) ReadInputRegisters (code:4) ReadMultipleHoldingRegisters (code:3)
            WriteSingleHoldingRegister (code:6) WriteMultipleHoldingRegisters (code:16) the enum "Primitives" means, that the current register Type supports Single Trasnactions If dpSizeNrRegistarts
            is &gt;1, also the multiple access functions must be supported 
          </documentation>
        </annotation>
      </element>
    </sequence>
  </complexType>
  <simpleType name="MasterFunctionsSupported">
    <annotation>
      <documentation>the selection of the supported Master access functions
      </documentation>
    </annotation>
    <restriction base="string">
      <enumeration value="Primitives">
        <annotation>
          <documentation>
            "Primitives" support ReadDiscreteInputs (code: 2) ReadCoils (code: 1) WriteSingleCoil (code: 5) ReadInputRegisters (code:4) WriteSingleHoldingRegister (code:6) for single
            Register access if numberOfRegisters &gt; 1 "Primitives" supports ReadMultipleHoldingRegisters (code:3) WriteMultipleCoils (code:15) WriteMultipleHoldingRegisters (code:16) for the
            register Type being adressed 
          </documentation>
        </annotation>
      </enumeration>
      <enumeration value="ReadDiscreteInputs">
        <annotation>
          <documentation>Master function code= 2</documentation>
        </annotation>
      </enumeration>
      <enumeration value="ReadCoils">
        <annotation>
          <documentation>Master function code: 1</documentation>
        </annotation>
      </enumeration>
      <enumeration value="WriteSingleCoil">
        <annotation>
          <documentation>Master function code: 5</documentation>
        </annotation>
      </enumeration>
      <enumeration value="WriteMultipleCoils">
        <annotation>
          <documentation>Master function code:15</documentation>
        </annotation>
      </enumeration>
      <enumeration value="ReadInputRegisters">
        <annotation>
          <documentation>Master function code:4</documentation>
        </annotation>
      </enumeration>
      <enumeration value="ReadMultipleHoldingRegisters">
        <annotation>
          <documentation>Master function code:3</documentation>
        </annotation>
      </enumeration>
      <enumeration value="WriteSingleHoldingRegister">
        <annotation>
          <documentation>Master function code:6</documentation>
        </annotation>
      </enumeration>
      <enumeration value="WriteMultipleHoldingRegisters">
        <annotation>
          <documentation>Master function code:16</documentation>
        </annotation>
      </enumeration>
      <enumeration value="ReadWriteMultipleRegisters">
        <annotation>
          <documentation>Master function code:23</documentation>
        </annotation>
      </enumeration>
      <enumeration value="MaskWriteRegister">
        <annotation>
          <documentation>Master function code:22</documentation>
        </annotation>
      </enumeration>
      <enumeration value="ReadFIFOQueue">
        <annotation>
          <documentation>Master function code:24</documentation>
        </annotation>
      </enumeration>
      <enumeration value="ReadFileRecord">
        <annotation>
          <documentation>Master function code:20</documentation>
        </annotation>
      </enumeration>
      <enumeration value="WriteFileRecord">
        <annotation>
          <documentation>Master function code:21</documentation>
        </annotation>
      </enumeration>
      <enumeration value="ReadExceptionStatus">
        <annotation>
          <documentation>Master function code:7</documentation>
        </annotation>
      </enumeration>
      <enumeration value="Diagnostic">
        <annotation>
          <documentation>Master function code:8</documentation>
        </annotation>
      </enumeration>
      <enumeration value="GetComEventCounter">
        <annotation>
          <documentation>Master function code:11</documentation>
        </annotation>
      </enumeration>
      <enumeration value="GetComEventLog">
        <annotation>
          <documentation>Master function code:12</documentation>
        </annotation>
      </enumeration>
      <enumeration value="ReportSlaveID">
        <annotation>
          <documentation>Master function code:17</documentation>
        </annotation>
      </enumeration>
      <enumeration value="ReadDeviceIdentification">
        <annotation>
          <documentation>Master function code:43</documentation>
        </annotation>
      </enumeration>
    </restriction>
  </simpleType>
  <complexType name="AccessProtectionEnabled">
    <annotation>
      <documentation>
        Modbus datapoints may be protected by execptions. If this is the case, a datapoint may be selected as true with a range of supported exceptions. A NOT listed exception means no XY
        exception
      </documentation>
    </annotation>
    <sequence>
      <element name="modbusExceptionCode" type="sgr:ModbusExceptionCode" maxOccurs="unbounded" minOccurs="1"/>
      <element name="isEnabled" type="boolean" maxOccurs="1" minOccurs="1" />
    </sequence>
  </complexType>
  <simpleType name="ModbusLayer6Deviation">
    <annotation>
      <documentation>this type is used to manage non standard data type definitions at ISO/OSI Layer 6</documentation>
    </annotation>
    <restriction base="string">
      <enumeration value="2RegBase1000_L2H">
        <annotation>
          <documentation>2 Registers show a combined value, as example in kWh and MWh beginning with lower range @ lower address</documentation>
        </annotation>
      </enumeration>
      <enumeration value="2RegBase1000_H2L">
        <annotation>
          <documentation>2 Registers show a combined value, as example in kWh and MWh beginning with lower range @ higher address</documentation>
        </annotation>
      </enumeration>
      <enumeration value="SGReadyEnum2IO_H2L">
        <annotation>
          <documentation>2 Registers combine SGready IO1 and IO2 into the sgreadyStateLv2 enum beginning with IO1 @ higher address</documentation>
        </annotation>
      </enumeration>
      <enumeration value="SGReadyEnum2IO_L2H">
        <annotation>
          <documentation>2 Registers combine SGready IO1 and IO2 into the sgreadyStateLv2 enum beginning with IO1 @ lower address</documentation>
        </annotation>
      </enumeration>
    </restriction>
  </simpleType>
  <complexType name="ModbusEnumMapper">
    <annotation>
      <documentation>
        Enumerations typically define operation modes or singlular states. Devices use different control schemes, SmartGridrady defines a commmon information model for interoperable
        behaviour. At interface class level, enums may use different binary values.
      </documentation>
    </annotation>
    <sequence>
      <annotation>
        <documentation>
          modbusEnumMapper uses indexes as the value of the generic definition, the value of shows the proprietary value. (Write data direction) genEnumMapper uses indexes as the value
          of the proprietary definition, the value shows the generic value (Read data direction) This value is index of the enum list representation of the bit 0 means BIT0 65535 means DO NOT MAP,
          UNKNOWN
        </documentation>
      </annotation>
      <element name="modbusEnumMapper" type="unsignedInt" maxOccurs="unbounded" minOccurs="1">
      </element>
      <element name="genEnumMapper" type="unsignedInt" maxOccurs="unbounded" minOccurs="1">
      </element>
    </sequence>
  </complexType>
  <complexType name="ModbusBitmapMapper">
    <annotation>
      <documentation>
        Bitmaps typically define operation modes or parallel active states. Devices use different control schemes, SmartGridrady defines a commmon information model for interoperable
        behaviour. At interface class level, Bitmaps may use different binary values.
      </documentation>
    </annotation>
    <sequence>
      <annotation>
        <documentation>
          modbusBitMapper uses indexes as the value of the generic definition, the value of shows the proprietary value. (Write data direction) genericBitMapper uses indexes as the value of
          the proprietary definition, the value shows the generic value (Read data direction)
        </documentation>
      </annotation>
      <element name="modbusBitMapper" type="unsignedInt" maxOccurs="unbounded" minOccurs="1">
      </element>
      <element name="genericBitMapper" type="unsignedInt" maxOccurs="unbounded" minOccurs="1">
      </element>
    </sequence>
  </complexType>
  <complexType name="ModbusBooleanMapper">
    <annotation>
      <documentation>
        Booleans at modbus level may be true if 1, 0, 0xff, -1 , all but not a certain value . isPositiveLogic is true if a number must contain a specific value to be valid
        isPositiveLogic is false if a number must contain any but NOT a specific value to be valid
      </documentation>
    </annotation>
    <sequence>
      <element name="isPositiveLogic" type="boolean" maxOccurs="1" minOccurs="1"></element>
      <element name="value" type="unsignedInt" maxOccurs="1" minOccurs="1"></element>
    </sequence>
  </complexType>
</schema>